generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model authors {
  id           String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  first_name   String         @db.VarChar(255)
  last_name    String         @db.VarChar(255)
  middle_name  String?        @db.VarChar(255)
  item_authors item_authors[]
}

model citations {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id        String   @db.Uuid
  citation_style String   @db.VarChar(50)
  citation_text  String
  date_generated DateTime @default(now()) @db.Timestamptz(6)
  items          items    @relation(fields: [item_id], references: [id], onDelete: Cascade)
}

model collections {
  id                   String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                 String             @db.VarChar(255)
  description          String?
  parent_collection_id String?            @db.Uuid
  date_added           DateTime           @default(now()) @db.Timestamptz(6)
  date_modified        DateTime           @default(now()) @db.Timestamptz(6)
  collections          collections?       @relation("collectionsTocollections", fields: [parent_collection_id], references: [id])
  other_collections    collections[]      @relation("collectionsTocollections")
  item_collections     item_collections[]
}

model item_archives {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id    String   @db.Uuid
  file_type  String   @db.VarChar(10)
  file_size  Int
  file_hash  String   @db.VarChar(255)
  add_date   DateTime @default(now()) @db.Timestamptz(6)
  s3_key     String   @db.VarChar(500)
  page_count Int
  word_count Int?
  items      items    @relation(fields: [item_id], references: [id], onDelete: Cascade)
}

model item_authors {
  id        String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id   String  @db.Uuid
  author_id String  @db.Uuid
  authors   authors @relation(fields: [author_id], references: [id], onDelete: Cascade)
  items     items   @relation(fields: [item_id], references: [id], onDelete: Cascade)

  @@unique([item_id, author_id])
}

model item_collections {
  id            String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id       String      @db.Uuid
  collection_id String      @db.Uuid
  collections   collections @relation(fields: [collection_id], references: [id], onDelete: Cascade)
  items         items       @relation(fields: [item_id], references: [id], onDelete: Cascade)

  @@unique([item_id, collection_id])
}

model items {
  id                    String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title                 String               @db.VarChar(500)
  abstract              String?
  publication_year      Int?
  publisher             String?              @db.VarChar(255)
  isbn                  String?              @db.VarChar(20)
  doi                   String?              @db.VarChar(255)
  url                   String?              @db.VarChar(500)
  tags                  String[]             @default([])
  notes                 String?
  date_added            DateTime             @default(now()) @db.Timestamptz(6)
  date_modified         DateTime             @default(now()) @db.Timestamptz(6)
  language              String?              @db.VarChar(10)
  markdown_content      String?
  markdown_updated_date DateTime?            @db.Timestamptz(6)
  chunk_embed_groups    chunk_embed_groups[]
  citations             citations[]
  item_archives         item_archives[]
  item_authors          item_authors[]
  item_chunks           item_chunks[]
  item_collections      item_collections[]
  markdowns             markdowns?
}

model markdowns {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id       String   @unique @db.Uuid
  content       String
  date_created  DateTime @default(now()) @db.Timestamptz(6)
  date_modified DateTime @default(now()) @db.Timestamptz(6)
  items         items    @relation(fields: [item_id], references: [id], onDelete: Cascade)
}

model chunk_embed_groups {
  id               String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id          String        @db.Uuid
  name             String        @db.VarChar(255)
  description      String?
  chunking_config  Json
  embedding_config Json
  is_default       Boolean       @default(false)
  is_active        Boolean       @default(true)
  created_at       DateTime      @default(now()) @db.Timestamptz(6)
  updated_at       DateTime      @default(now()) @db.Timestamptz(6)
  created_by       String?       @db.VarChar(255)
  tags             String[]      @default([])
  status           String        @default("WAIT_FOR_CHUNK_EMBED") @db.VarChar(50)
  items            items         @relation(fields: [item_id], references: [id], onDelete: Cascade)
  item_chunks      item_chunks[]

  @@index([item_id])
  @@index([status])
  @@index([is_active])
}

model item_chunks {
  id                          String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  item_id                     String             @db.Uuid
  dense_vector_index_group_id String             @db.Uuid
  title                       String             @db.VarChar(500)
  content                     String
  index                       Int
  embedding                   Unsupported("VECTOR")?
  strategy_metadata           Json
  metadata                    Json?
  created_at                  DateTime           @default(now()) @db.Timestamptz(6)
  updated_at                  DateTime           @default(now()) @db.Timestamptz(6)
  chunk_embed_groups          chunk_embed_groups @relation(fields: [dense_vector_index_group_id], references: [id], onDelete: Cascade)
  items                       items              @relation(fields: [item_id], references: [id], onDelete: Cascade)

  @@index([item_id])
  @@index([dense_vector_index_group_id])
  @@index([index])
}
