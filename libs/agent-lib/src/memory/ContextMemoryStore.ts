/**
 * ContextMemoryStore - Stores all context generated during conversation
 *
 * This store maintains a complete history of all workspace contexts and summaries
 * for reference and recall purposes. Contexts are not directly injected into prompts
 * but can be retrieved when needed.
 */

export interface ContextSnapshot {
    /** Unique identifier for this context snapshot */
    id: string;
    /** Timestamp when this context was captured */
    timestamp: number;
    /** The turn/round number in the conversation */
    turnNumber: number;
    /** Full workspace context at this point */
    fullContext: string;
    /** Compressed summary of this context (generated by LLM) */
    summary?: string;
    /** Token count of the full context */
    tokenCount: number;
    /** Associated tool calls in this turn */
    toolCalls?: string[];
}

export interface MemorySummary {
    /** Summary ID */
    id: string;
    /** Reference to the original context snapshot */
    contextId: string;
    /** Turn number */
    turnNumber: number;
    /** Compressed summary text */
    summary: string;
    /** Key insights extracted from this turn */
    insights: string[];
    /** Token count of the summary */
    tokenCount: number;
    /** Timestamp */
    timestamp: number;
}

export class ContextMemoryStore {
    /** All context snapshots indexed by ID */
    private contexts: Map<string, ContextSnapshot> = new Map();

    /** All summaries indexed by ID */
    private summaries: Map<string, MemorySummary> = new Map();

    /** Mapping from turn number to context ID */
    private turnToContext: Map<number, string> = new Map();

    /** Current turn number */
    private currentTurn: number = 0;

    /**
     * Store a new context snapshot
     */
    storeContext(fullContext: string, toolCalls?: string[]): ContextSnapshot {
        this.currentTurn++;

        const snapshot: ContextSnapshot = {
            id: `ctx_${this.currentTurn}_${Date.now()}`,
            timestamp: Date.now(),
            turnNumber: this.currentTurn,
            fullContext,
            tokenCount: this.estimateTokens(fullContext),
            toolCalls,
        };

        this.contexts.set(snapshot.id, snapshot);
        this.turnToContext.set(this.currentTurn, snapshot.id);

        return snapshot;
    }

    /**
     * Store a summary for a context
     */
    storeSummary(contextId: string, summary: string, insights: string[]): MemorySummary {
        const context = this.contexts.get(contextId);
        if (!context) {
            throw new Error(`Context ${contextId} not found`);
        }

        const memorySummary: MemorySummary = {
            id: `sum_${contextId}`,
            contextId,
            turnNumber: context.turnNumber,
            summary,
            insights,
            tokenCount: this.estimateTokens(summary),
            timestamp: Date.now(),
        };

        this.summaries.set(memorySummary.id, memorySummary);

        // Update context with summary reference
        context.summary = summary;

        return memorySummary;
    }

    /**
     * Retrieve a context by ID
     */
    getContext(contextId: string): ContextSnapshot | undefined {
        return this.contexts.get(contextId);
    }

    /**
     * Retrieve a context by turn number
     */
    getContextByTurn(turnNumber: number): ContextSnapshot | undefined {
        const contextId = this.turnToContext.get(turnNumber);
        return contextId ? this.contexts.get(contextId) : undefined;
    }

    /**
     * Retrieve a summary by context ID
     */
    getSummary(contextId: string): MemorySummary | undefined {
        return this.summaries.get(`sum_${contextId}`);
    }

    /**
     * Get all summaries in chronological order
     */
    getAllSummaries(): MemorySummary[] {
        return Array.from(this.summaries.values())
            .sort((a, b) => a.turnNumber - b.turnNumber);
    }

    /**
     * Get recent summaries (last N turns)
     */
    getRecentSummaries(count: number): MemorySummary[] {
        const allSummaries = this.getAllSummaries();
        return allSummaries.slice(-count);
    }

    /**
     * Search summaries by keyword
     */
    searchSummaries(keyword: string): MemorySummary[] {
        return Array.from(this.summaries.values())
            .filter(s =>
                s.summary.toLowerCase().includes(keyword.toLowerCase()) ||
                s.insights.some(i => i.toLowerCase().includes(keyword.toLowerCase()))
            )
            .sort((a, b) => a.turnNumber - b.turnNumber);
    }

    /**
     * Get total token count of all summaries
     */
    getTotalSummaryTokens(): number {
        return Array.from(this.summaries.values())
            .reduce((total, s) => total + s.tokenCount, 0);
    }

    /**
     * Get current turn number
     */
    getCurrentTurn(): number {
        return this.currentTurn;
    }

    /**
     * Clear all stored data
     */
    clear(): void {
        this.contexts.clear();
        this.summaries.clear();
        this.turnToContext.clear();
        this.currentTurn = 0;
    }

    /**
     * Estimate token count (rough approximation)
     */
    private estimateTokens(text: string): number {
        return Math.ceil(text.length / 4);
    }

    /**
     * Export memory state for persistence
     */
    export(): {
        contexts: ContextSnapshot[];
        summaries: MemorySummary[];
        currentTurn: number;
    } {
        return {
            contexts: Array.from(this.contexts.values()),
            summaries: Array.from(this.summaries.values()),
            currentTurn: this.currentTurn,
        };
    }

    /**
     * Import memory state from persistence
     */
    import(data: {
        contexts: ContextSnapshot[];
        summaries: MemorySummary[];
        currentTurn: number;
    }): void {
        this.clear();

        for (const ctx of data.contexts) {
            this.contexts.set(ctx.id, ctx);
            this.turnToContext.set(ctx.turnNumber, ctx.id);
        }

        for (const sum of data.summaries) {
            this.summaries.set(sum.id, sum);
        }

        this.currentTurn = data.currentTurn;
    }
}
