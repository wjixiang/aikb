// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.21.12
// source: libraryItemVector.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from '@nestjs/microservices';
import { Observable } from 'rxjs';

export const protobufPackage = 'libraryItemVector';

/** Chunking configuration */
export interface ChunkingConfig {
  /** e.g., 'h1', 'paragraph', 'semantic' */
  strategy: string;
  /** Strategy-specific parameters */
  parameters: { [key: string]: string };
}

export interface ChunkingConfig_ParametersEntry {
  key: string;
  value: string;
}

/** Embedding configuration */
export interface EmbeddingConfig {
  /** e.g., 'openai', 'cohere', 'local' */
  provider: string;
  /** e.g., 'text-embedding-ada-002' */
  model: string;
  /** Vector dimension */
  dimension: number;
  /** Provider-specific parameters */
  parameters: { [key: string]: string };
}

export interface EmbeddingConfig_ParametersEntry {
  key: string;
  value: string;
}

/** Request to create a new chunk embedding group */
export interface CreateChunkEmbedGroupRequest {
  name: string;
  description: string;
  chunkingConfig: ChunkingConfig | undefined;
  embeddingConfig: EmbeddingConfig | undefined;
  isDefault: boolean;
  isActive: boolean;
  createdBy: string;
  tags: string[];
}

/** Response containing the created chunk embedding group */
export interface CreateChunkEmbedGroupResponse {
  group: ChunkEmbedGroupMetadata | undefined;
}

/** Chunk embedding group metadata */
export interface ChunkEmbedGroupMetadata {
  id: string;
  name: string;
  description: string;
  chunkingConfig: ChunkingConfig | undefined;
  embeddingConfig: EmbeddingConfig | undefined;
  isDefault: boolean;
  isActive: boolean;
  createdAt: number;
  updatedAt: number;
  createdBy: string;
  tags: string[];
}

export interface ListItemChunkEmbedGroupMetadataRequest {
  /** ID of target item */
  id: string;
  /** Pagination */
  pageSize: number;
  pageToken: string;
  filter: string;
  orderBy: string;
}

export interface ListItemChunkEmbedGroupMetadataResponse {
  groups: ChunkEmbedGroupMetadata[];
  nextPageToken: string;
  totalSize: number;
}

export interface EmbedChunksRequest {
  chunkEmbedGroupId: string;
  chunks: ChunkData[];
}

export interface ChunkData {
  itemId: string;
  title: string;
  content: string;
  index: number;
  metadata: { [key: string]: string };
}

export interface ChunkData_MetadataEntry {
  key: string;
  value: string;
}

export interface EmbedChunksResponse {
  success: boolean;
  message: string;
  chunkIds: string[];
}

export interface SemanticSearchByItemidAndGroupidRequest {
  itemId: string;
  chunkEmbedGroupId: string;
  query: string;
  topK: number;
  scoreThreshold: number;
  filter: { [key: string]: string };
}

export interface SemanticSearchByItemidAndGroupidRequest_FilterEntry {
  key: string;
  value: string;
}

export interface SemanticSearchByItemidAndGroupidResponse {
  success: boolean;
  message: string;
  results: SemanticSearchResult[];
}

export interface SemanticSearchResult {
  chunkId: string;
  itemId: string;
  title: string;
  content: string;
  score: number;
  metadata: { [key: string]: string };
}

export interface SemanticSearchResult_MetadataEntry {
  key: string;
  value: string;
}

export const LIBRARY_ITEM_VECTOR_PACKAGE_NAME = 'libraryItemVector';

/** Library Item Vector service definition */

export interface LibraryItemVectorServiceClient {
  /** Create a new chunk embedding group */

  createChunkEmbedGroup(
    request: CreateChunkEmbedGroupRequest,
  ): Observable<CreateChunkEmbedGroupResponse>;

  listChunkEmbedGroupMetadata(
    request: ListItemChunkEmbedGroupMetadataRequest,
  ): Observable<ListItemChunkEmbedGroupMetadataResponse>;

  embedChunks(request: EmbedChunksRequest): Observable<EmbedChunksResponse>;

  semanticSearchByItemidAndGroupid(
    request: SemanticSearchByItemidAndGroupidRequest,
  ): Observable<SemanticSearchByItemidAndGroupidResponse>;
}

/** Library Item Vector service definition */

export interface LibraryItemVectorServiceController {
  /** Create a new chunk embedding group */

  createChunkEmbedGroup(
    request: CreateChunkEmbedGroupRequest,
  ):
    | Promise<CreateChunkEmbedGroupResponse>
    | Observable<CreateChunkEmbedGroupResponse>
    | CreateChunkEmbedGroupResponse;

  listChunkEmbedGroupMetadata(
    request: ListItemChunkEmbedGroupMetadataRequest,
  ):
    | Promise<ListItemChunkEmbedGroupMetadataResponse>
    | Observable<ListItemChunkEmbedGroupMetadataResponse>
    | ListItemChunkEmbedGroupMetadataResponse;

  embedChunks(
    request: EmbedChunksRequest,
  ):
    | Promise<EmbedChunksResponse>
    | Observable<EmbedChunksResponse>
    | EmbedChunksResponse;

  semanticSearchByItemidAndGroupid(
    request: SemanticSearchByItemidAndGroupidRequest,
  ):
    | Promise<SemanticSearchByItemidAndGroupidResponse>
    | Observable<SemanticSearchByItemidAndGroupidResponse>
    | SemanticSearchByItemidAndGroupidResponse;
}

export function LibraryItemVectorServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      'createChunkEmbedGroup',
      'listChunkEmbedGroupMetadata',
      'embedChunks',
      'semanticSearchByItemidAndGroupid',
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod('LibraryItemVectorService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod('LibraryItemVectorService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const LIBRARY_ITEM_VECTOR_SERVICE_NAME = 'LibraryItemVectorService';
