/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { BamlRuntime, FunctionResult, BamlCtxManager, Image, Audio, Pdf, Video, FunctionLog,
HTTPRequest } from "@boundaryml/baml"
import { toBamlError, BamlStream, BamlAbortError, Collector, ClientRegistry } from "@boundaryml/baml"
import type { Checked, Check, RecursivePartialNull as MovedRecursivePartialNull } from "./types"
import type { partial_types } from "./partial_types"
import type * as types from "./types"
import type {AdministrationRoute, AgeGroup, AllocationConcealment, Article, ArticleType, BiasAssessmentTool, BiasRiskLevel, BlindingType, CombinationIntervention, ComparisonCriteria, ComparisonDoseType, ComparisonSpecificity, ComparisonType, ComplianceStandard, ConflictOfInterest, CountryIncomeLevel, CriteriaType, Criterion, DataFormat, DataQualityCriteria, Database, DateRange, DiseaseActivity, DiseaseCourse, DoseType, EffectSize, EthicsComplianceCriteria, ExposureDuration, ExposureIntensity, ExposureType, FollowUpDuration, FollowUpTime, FundingSource, GenderRequirement, GreyLiterature, HospitalLevel, InclusionExclusionCriteria, InterventionCategory, InterventionCriteria, JournalFilters, Language, LogicalOperator, MeSHTerm, MeasurementMethod, MedicalSetting, MetaAnalysisQuestion, MetaAnalysisResult, MethodologicalQualityCriteria, ObservationalStudyType, OutcomeAssessorBlinding, OutcomeCategory, OutcomeCriteria, OutcomeDataType, OutcomeNature, PICO, PICOSearchStrategy, PeerReviewStatus, PopulationCriteria, PubMedAgeGroup, PubMedField, PublicationCriteria, PublicationFilters, PublicationLanguage, PublicationType, QueryRefinement, RCTDesignType, RandomizationMethod, RenderedQuery, ScreeningDecision, SearchBlock, SearchConcept, SearchConfig, SearchDateRange, SearchOptions, SearchResultEvaluation, SearchStrategy, SearchTerm, SettingCriteria, Sex, SpecialPopulation, Species, StatisticalAnalysis, StrategyEvaluation, StudyDesignCriteria, StudyDesignType, StudyExtraction, StudyNature, StudyScale, TreatmentFrequency, TreatmentHistory, TreatmentTiming, TrialPhase, UrbanRural} from "./types"
import type TypeBuilder from "./type_builder"
import { AsyncHttpRequest, AsyncHttpStreamRequest } from "./async_request"
import { LlmResponseParser, LlmStreamParser } from "./parser"
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"
import type * as events from "./events"

/**
* @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
*/
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>

    type TickReason = "Unknown";

    type BamlCallOptions<WatchersT = never> = {
    tb?: TypeBuilder
    clientRegistry?: ClientRegistry
    client?: string
    collector?: Collector | Collector[]
    env?: Record<string, string | undefined>
      tags?: Record<string, string>
        signal?: AbortSignal
        onTick?: (reason: TickReason, log: FunctionLog | null) => void
        watchers?: WatchersT
        }

        export class BamlAsyncClient {
        private runtime: BamlRuntime
        private ctxManager: BamlCtxManager
        private streamClient: BamlStreamClient
        private httpRequest: AsyncHttpRequest
        private httpStreamRequest: AsyncHttpStreamRequest
        private llmResponseParser: LlmResponseParser
        private llmStreamParser: LlmStreamParser
        private bamlOptions: BamlCallOptions

        constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
        this.runtime = runtime
        this.ctxManager = ctxManager
        this.streamClient = new BamlStreamClient(runtime, ctxManager, bamlOptions)
        this.httpRequest = new AsyncHttpRequest(runtime, ctxManager)
        this.httpStreamRequest = new AsyncHttpStreamRequest(runtime, ctxManager)
        this.llmResponseParser = new LlmResponseParser(runtime, ctxManager)
        this.llmStreamParser = new LlmStreamParser(runtime, ctxManager)
        this.bamlOptions = bamlOptions || {}
        }

        withOptions(bamlOptions: BamlCallOptions) {
        return new BamlAsyncClient(this.runtime, this.ctxManager, bamlOptions)
        }

        get stream() {
        return this.streamClient
        }

        get request() {
        return this.httpRequest
        }

        get streamRequest() {
        return this.httpStreamRequest
        }

        get parse() {
        return this.llmResponseParser
        }

        get parseStream() {
        return this.llmStreamParser
        }

        
        async CombineSearchStrategies(
        strategies: types.SearchStrategy[],method: string,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.SearchStrategy> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.CombineSearchStrategies(
          strategies,method,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "CombineSearchStrategies",
            {
            "strategies": strategies,"method": method
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.SearchStrategy
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async EvaluateCriteria(
        study: string,criteria: types.InclusionExclusionCriteria,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<string> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.EvaluateCriteria(
          study,criteria,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "EvaluateCriteria",
            {
            "study": study,"criteria": criteria
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as string
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async EvaluateSearchResults(
        research_question: string,search_query: string,articles: types.Article[],iteration: number,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.SearchResultEvaluation> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.EvaluateSearchResults(
          research_question,search_query,articles,iteration,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "EvaluateSearchResults",
            {
            "research_question": research_question,"search_query": search_query,"articles": articles,"iteration": iteration
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.SearchResultEvaluation
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async EvaluateSearchStrategy(
        strategy: types.SearchStrategy,sample_results: string,target_result_count?: number | null,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.StrategyEvaluation> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.EvaluateSearchStrategy(
          strategy,sample_results,target_result_count,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "EvaluateSearchStrategy",
            {
            "strategy": strategy,"sample_results": sample_results,"target_result_count": target_result_count?? null
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.StrategyEvaluation
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async ExtractMeSHTerms(
        concept_description: string,include_qualifiers: boolean,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.MeSHTerm[]> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.ExtractMeSHTerms(
          concept_description,include_qualifiers,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "ExtractMeSHTerms",
            {
            "concept_description": concept_description,"include_qualifiers": include_qualifiers
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.MeSHTerm[]
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async ExtractPICOFromQuestion(
        research_question: string,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.PICO> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.ExtractPICOFromQuestion(
          research_question,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "ExtractPICOFromQuestion",
            {
            "research_question": research_question
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.PICO
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async ExtractStudyData(
        research_question: string,articles: types.Article[],
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.StudyExtraction[]> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.ExtractStudyData(
          research_question,articles,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "ExtractStudyData",
            {
            "research_question": research_question,"articles": articles
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.StudyExtraction[]
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async GenerateCriteria(
        research_question: string,pico: types.PICO,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.InclusionExclusionCriteria> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.GenerateCriteria(
          research_question,pico,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "GenerateCriteria",
            {
            "research_question": research_question,"pico": pico
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.InclusionExclusionCriteria
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async GenerateKeywords(
        concept_description: string,include_variants: boolean,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<string[]> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.GenerateKeywords(
          concept_description,include_variants,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "GenerateKeywords",
            {
            "concept_description": concept_description,"include_variants": include_variants
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as string[]
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async GenerateMetaAnalysisReport(
        result: types.MetaAnalysisResult,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<string> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.GenerateMetaAnalysisReport(
          result,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "GenerateMetaAnalysisReport",
            {
            "result": result
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as string
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async GenerateMetaAnalysisSearchQuery(
        question: types.MetaAnalysisQuestion,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<string> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.GenerateMetaAnalysisSearchQuery(
          question,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "GenerateMetaAnalysisSearchQuery",
            {
            "question": question
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as string
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async GenerateSearchStrategy(
        research_question: string,pico: types.PICO,criteria?: types.InclusionExclusionCriteria | null,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.SearchStrategy> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.GenerateSearchStrategy(
          research_question,pico,criteria,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "GenerateSearchStrategy",
            {
            "research_question": research_question,"pico": pico,"criteria": criteria?? null
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.SearchStrategy
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async RefineSearchQuery(
        research_question: string,current_query: string,evaluation: types.SearchResultEvaluation,iteration: number,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.QueryRefinement> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.RefineSearchQuery(
          research_question,current_query,evaluation,iteration,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "RefineSearchQuery",
            {
            "research_question": research_question,"current_query": current_query,"evaluation": evaluation,"iteration": iteration
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.QueryRefinement
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async RenderSearchQuery(
        strategy: types.SearchStrategy,database: types.Database,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.RenderedQuery> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.RenderSearchQuery(
          strategy,database,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "RenderSearchQuery",
            {
            "strategy": strategy,"database": database
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.RenderedQuery
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async ScreenArticles(
        research_question: string,articles: types.Article[],
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.ScreeningDecision[]> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.ScreenArticles(
          research_question,articles,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "ScreenArticles",
            {
            "research_question": research_question,"articles": articles
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.ScreeningDecision[]
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async SynthesizeMetaAnalysis(
        research_question: string,studies: types.StudyExtraction[],
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.MetaAnalysisResult> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.SynthesizeMetaAnalysis(
          research_question,studies,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "SynthesizeMetaAnalysis",
            {
            "research_question": research_question,"studies": studies
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.MetaAnalysisResult
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
        async TranslateSearchStrategy(
        strategy: types.SearchStrategy,target_database: types.Database,
        __baml_options__?: BamlCallOptions<never>
        ): Promise<types.SearchStrategy> {
          try {
          const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
          const __signal__ = __options__.signal;

          if (__signal__?.aborted) {
          throw new BamlAbortError('Operation was aborted', __signal__.reason);
          }

          // Check if onTick is provided - route through streaming if so
          if (__options__.onTick) {
          const __stream__ = this.stream.TranslateSearchStrategy(
          strategy,target_database,
          __baml_options__
          );

          return await __stream__.getFinalResponse();
          }

          const __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
          [__options__.collector]) : [];
          const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
          const __env__: Record<string, string> = Object.fromEntries(
            Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
            );

            // Resolve client option to clientRegistry (client takes precedence)
            let __clientRegistry__ = __options__.clientRegistry;
            if (__options__.client) {
              __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
              __clientRegistry__.setPrimary(__options__.client);
            }

            const __raw__ = await this.runtime.callFunction(
            "TranslateSearchStrategy",
            {
            "strategy": strategy,"target_database": target_database
            },
            this.ctxManager.cloneContext(),
            __options__.tb?.__tb(),
            __clientRegistry__,
            __collector__,
            __options__.tags || {},
            __env__,
            __signal__,
            __options__.watchers,
            )
            return __raw__.parsed(false) as types.SearchStrategy
            } catch (error) {
            throw toBamlError(error);
            }
            }
            
            }

            class BamlStreamClient {
            private runtime: BamlRuntime
            private ctxManager: BamlCtxManager
            private bamlOptions: BamlCallOptions

            constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
            this.runtime = runtime
            this.ctxManager = ctxManager
            this.bamlOptions = bamlOptions || {}
            }

            
            CombineSearchStrategies(
            strategies: types.SearchStrategy[],method: string,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.SearchStrategy, types.SearchStrategy>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for CombineSearchStrategies", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "CombineSearchStrategies",
                {
                "strategies": strategies,"method": method
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.SearchStrategy, types.SearchStrategy>(
                  __raw__,
                  (a): partial_types.SearchStrategy => a,
                  (a): types.SearchStrategy => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            EvaluateCriteria(
            study: string,criteria: types.InclusionExclusionCriteria,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<string, string>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for EvaluateCriteria", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "EvaluateCriteria",
                {
                "study": study,"criteria": criteria
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<string, string>(
                  __raw__,
                  (a): string => a,
                  (a): string => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            EvaluateSearchResults(
            research_question: string,search_query: string,articles: types.Article[],iteration: number,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.SearchResultEvaluation, types.SearchResultEvaluation>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for EvaluateSearchResults", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "EvaluateSearchResults",
                {
                "research_question": research_question,"search_query": search_query,"articles": articles,"iteration": iteration
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.SearchResultEvaluation, types.SearchResultEvaluation>(
                  __raw__,
                  (a): partial_types.SearchResultEvaluation => a,
                  (a): types.SearchResultEvaluation => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            EvaluateSearchStrategy(
            strategy: types.SearchStrategy,sample_results: string,target_result_count?: number | null,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.StrategyEvaluation, types.StrategyEvaluation>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for EvaluateSearchStrategy", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "EvaluateSearchStrategy",
                {
                "strategy": strategy,"sample_results": sample_results,"target_result_count": target_result_count ?? null
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.StrategyEvaluation, types.StrategyEvaluation>(
                  __raw__,
                  (a): partial_types.StrategyEvaluation => a,
                  (a): types.StrategyEvaluation => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            ExtractMeSHTerms(
            concept_description: string,include_qualifiers: boolean,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.MeSHTerm[], types.MeSHTerm[]>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for ExtractMeSHTerms", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "ExtractMeSHTerms",
                {
                "concept_description": concept_description,"include_qualifiers": include_qualifiers
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.MeSHTerm[], types.MeSHTerm[]>(
                  __raw__,
                  (a): partial_types.MeSHTerm[] => a,
                  (a): types.MeSHTerm[] => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            ExtractPICOFromQuestion(
            research_question: string,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.PICO, types.PICO>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for ExtractPICOFromQuestion", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "ExtractPICOFromQuestion",
                {
                "research_question": research_question
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.PICO, types.PICO>(
                  __raw__,
                  (a): partial_types.PICO => a,
                  (a): types.PICO => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            ExtractStudyData(
            research_question: string,articles: types.Article[],
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.StudyExtraction[], types.StudyExtraction[]>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for ExtractStudyData", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "ExtractStudyData",
                {
                "research_question": research_question,"articles": articles
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.StudyExtraction[], types.StudyExtraction[]>(
                  __raw__,
                  (a): partial_types.StudyExtraction[] => a,
                  (a): types.StudyExtraction[] => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            GenerateCriteria(
            research_question: string,pico: types.PICO,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.InclusionExclusionCriteria, types.InclusionExclusionCriteria>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for GenerateCriteria", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "GenerateCriteria",
                {
                "research_question": research_question,"pico": pico
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.InclusionExclusionCriteria, types.InclusionExclusionCriteria>(
                  __raw__,
                  (a): partial_types.InclusionExclusionCriteria => a,
                  (a): types.InclusionExclusionCriteria => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            GenerateKeywords(
            concept_description: string,include_variants: boolean,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<string[], string[]>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for GenerateKeywords", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "GenerateKeywords",
                {
                "concept_description": concept_description,"include_variants": include_variants
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<string[], string[]>(
                  __raw__,
                  (a): string[] => a,
                  (a): string[] => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            GenerateMetaAnalysisReport(
            result: types.MetaAnalysisResult,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<string, string>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for GenerateMetaAnalysisReport", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "GenerateMetaAnalysisReport",
                {
                "result": result
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<string, string>(
                  __raw__,
                  (a): string => a,
                  (a): string => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            GenerateMetaAnalysisSearchQuery(
            question: types.MetaAnalysisQuestion,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<string, string>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for GenerateMetaAnalysisSearchQuery", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "GenerateMetaAnalysisSearchQuery",
                {
                "question": question
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<string, string>(
                  __raw__,
                  (a): string => a,
                  (a): string => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            GenerateSearchStrategy(
            research_question: string,pico: types.PICO,criteria?: types.InclusionExclusionCriteria | null,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.SearchStrategy, types.SearchStrategy>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for GenerateSearchStrategy", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "GenerateSearchStrategy",
                {
                "research_question": research_question,"pico": pico,"criteria": criteria ?? null
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.SearchStrategy, types.SearchStrategy>(
                  __raw__,
                  (a): partial_types.SearchStrategy => a,
                  (a): types.SearchStrategy => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            RefineSearchQuery(
            research_question: string,current_query: string,evaluation: types.SearchResultEvaluation,iteration: number,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.QueryRefinement, types.QueryRefinement>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for RefineSearchQuery", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "RefineSearchQuery",
                {
                "research_question": research_question,"current_query": current_query,"evaluation": evaluation,"iteration": iteration
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.QueryRefinement, types.QueryRefinement>(
                  __raw__,
                  (a): partial_types.QueryRefinement => a,
                  (a): types.QueryRefinement => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            RenderSearchQuery(
            strategy: types.SearchStrategy,database: types.Database,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.RenderedQuery, types.RenderedQuery>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for RenderSearchQuery", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "RenderSearchQuery",
                {
                "strategy": strategy,"database": database
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.RenderedQuery, types.RenderedQuery>(
                  __raw__,
                  (a): partial_types.RenderedQuery => a,
                  (a): types.RenderedQuery => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            ScreenArticles(
            research_question: string,articles: types.Article[],
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.ScreeningDecision[], types.ScreeningDecision[]>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for ScreenArticles", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "ScreenArticles",
                {
                "research_question": research_question,"articles": articles
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.ScreeningDecision[], types.ScreeningDecision[]>(
                  __raw__,
                  (a): partial_types.ScreeningDecision[] => a,
                  (a): types.ScreeningDecision[] => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            SynthesizeMetaAnalysis(
            research_question: string,studies: types.StudyExtraction[],
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.MetaAnalysisResult, types.MetaAnalysisResult>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for SynthesizeMetaAnalysis", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "SynthesizeMetaAnalysis",
                {
                "research_question": research_question,"studies": studies
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.MetaAnalysisResult, types.MetaAnalysisResult>(
                  __raw__,
                  (a): partial_types.MetaAnalysisResult => a,
                  (a): types.MetaAnalysisResult => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
            TranslateSearchStrategy(
            strategy: types.SearchStrategy,target_database: types.Database,
            __baml_options__?: BamlCallOptions<never>
            ): BamlStream<partial_types.SearchStrategy, types.SearchStrategy>
              {
              try {
              const __options__ = { ...this.bamlOptions, ...(__baml_options__ || {}) }
              const __signal__ = __options__.signal;

              if (__signal__?.aborted) {
              throw new BamlAbortError('Operation was aborted', __signal__.reason);
              }

              let __collector__ = __options__.collector ? (Array.isArray(__options__.collector) ? __options__.collector :
              [__options__.collector]) : [];

              let __onTickWrapper__: (() => void) | undefined;

              // Create collector and wrap onTick if provided
              if (__options__.onTick) {
              const __tickCollector__ = new Collector("on-tick-collector");
              __collector__ = [...__collector__, __tickCollector__];

              __onTickWrapper__ = () => {
              const __log__ = __tickCollector__.last;
              if (__log__) {
              try {
              __options__.onTick!("Unknown", __log__);
              } catch (error) {
              console.error("Error in onTick callback for TranslateSearchStrategy", error);
              }
              }
              };
              }

              const __rawEnv__ = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
              const __env__: Record<string, string> = Object.fromEntries(
                Object.entries(__rawEnv__).filter(([_, value]) => value !== undefined) as [string, string][]
                );

                // Resolve client option to clientRegistry (client takes precedence)
                let __clientRegistry__ = __options__.clientRegistry;
                if (__options__.client) {
                  __clientRegistry__ = __clientRegistry__ || new ClientRegistry();
                  __clientRegistry__.setPrimary(__options__.client);
                }

                const __raw__ = this.runtime.streamFunction(
                "TranslateSearchStrategy",
                {
                "strategy": strategy,"target_database": target_database
                },
                undefined,
                this.ctxManager.cloneContext(),
                __options__.tb?.__tb(),
                __clientRegistry__,
                __collector__,
                __options__.tags || {},
                __env__,
                __signal__,
                __onTickWrapper__,
                )
                return new BamlStream<partial_types.SearchStrategy, types.SearchStrategy>(
                  __raw__,
                  (a): partial_types.SearchStrategy => a,
                  (a): types.SearchStrategy => a,
                  this.ctxManager.cloneContext(),
                  __options__.signal,
                  )
                  } catch (error) {
                  throw toBamlError(error);
                  }
                  }
                  
                  }

                  export const b = new BamlAsyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
                  DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)