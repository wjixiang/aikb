type Query {
  entities(where: entityWhereInput): [entity]!
  entity(where: entityWhereInput): entity
  documents(where: documentWhereInput): [document]!
  document(where: documentWhereInput): document
}

type Mutation {
  createEntity(input: createEntityInput): entity

  "Document Mutation"
  createDocument(input: createDocumentInput): document
  updateDocument(input: updateDocumentInput): document
  deleteDocument(input: deleteDocumentInput): document
}

type entity {
  id: ID!
  nomenclature: [nomenclature!]!
  definition: String!
}

type nomenclature {
  name: String!
  acronym: String
  language: String!
}

enum documentType {
  property
  relation
}

type document {
  id: ID!
  type: documentType!
  entities: [String!]!
  topic: String!
  metadata: documentMetadata
  record: [documentRecord]!
}

type documentMetadata {
  tags: [String]
}

type documentRecord {
  topic: String!
  content: String!
  updateDate: String!
}

input entityWhereInput {
  id: ID
  id_in: [ID!]
  id_not_in: [ID!]
  definition: String
  definition_semantic_search: semanticSearchInput
  definition_contains: String
  definition_starts_with: String
  definition_ends_with: String
  definition_in: [String!]
  definition_not_in: [String!]
  nomenclature: nomenclatureWhereInput
  nomenclature_some: nomenclatureWhereInput
  nomenclature_every: nomenclatureWhereInput
  nomenclature_none: nomenclatureWhereInput
  AND: [entityWhereInput!]
  OR: [entityWhereInput!]
  NOT: entityWhereInput
}

input semanticSearchInput {
  searchText: String!
  topK: Int
  threshold: Float
}

input nomenclatureWhereInput {
  name: String
  name_contains: String
  name_starts_with: String
  name_ends_with: String
  name_in: [String!]
  name_not_in: [String!]
  acronym: String
  acronym_contains: String
  acronym_starts_with: String
  acronym_ends_with: String
  acronym_in: [String!]
  acronym_not_in: [String!]
  acronym_is_null: Boolean
  language: String
  language_contains: String
  language_starts_with: String
  language_ends_with: String
  language_in: [String!]
  language_not_in: [String!]
  AND: [nomenclatureWhereInput!]
  OR: [nomenclatureWhereInput!]
  NOT: nomenclatureWhereInput
}

input createEntityInput {
  nomenclature: [nomenclatureInput!]!
  definition: String!
}

input nomenclatureInput {
  name: String!
  acronym: String
  language: String!
}

input createDocumentInput {
  type: documentType!
  entities: [String!]!
  topic: String!
  content: String!
}

input updateDocumentInput {
  documentId: String!
  type: documentType
  entities: [String]
  topic: String
  content: String
}

input deleteDocumentInput {
  documentId: String!
}

input documentWhereInput {
  id: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: documentType
  type_in: [documentType!]
  type_not_in: [documentType!]
  entities: String
  entities_in: [String!]
  entities_not_in: [String!]
  entities_contains: String
  entities_starts_with: String
  entities_ends_with: String
  topic: String
  topic_contains: String
  topic_starts_with: String
  topic_ends_with: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_semantic_search: semanticSearchInput
  metadata: documentMetadataWhereInput
  record: documentRecordWhereInput
  record_some: documentRecordWhereInput
  record_every: documentRecordWhereInput
  record_none: documentRecordWhereInput
  record_semantic_search: semanticSearchInput
  AND: [documentWhereInput!]
  OR: [documentWhereInput!]
  NOT: documentWhereInput
}

input documentMetadataWhereInput {
  tags: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_contains: String
  tags_starts_with: String
  tags_ends_with: String
  tags_is_null: Boolean
  AND: [documentMetadataWhereInput!]
  OR: [documentMetadataWhereInput!]
  NOT: documentMetadataWhereInput
}

input documentRecordWhereInput {
  topic: String
  topic_contains: String
  topic_starts_with: String
  topic_ends_with: String
  topic_in: [String!]
  topic_not_in: [String!]
  content: String
  content_contains: String
  content_starts_with: String
  content_ends_with: String
  content_in: [String!]
  content_not_in: [String!]
  updateDate: String
  updateDate_in: [String!]
  updateDate_not_in: [String!]
  AND: [documentRecordWhereInput!]
  OR: [documentRecordWhereInput!]
  NOT: documentRecordWhereInput
}
